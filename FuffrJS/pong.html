<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="user-scalable=no, initial-scale=1"/>
	<title>Pong</title>
</head>
<body>

<style>
html,body {
	width: 100%;
	height: 100%;
	margin: 0;
	padding: 0;
}
body {
	background:rgb(0,200,100);
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
	-webkit-tap-highlight-color:rgba(0,0,0,0);
	font-family: courier, monospace;
	font-size: 10em;
}

#playfield {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	z-index: 1;
	overflow: hidden;
}
#playfield.with-simulator {
	left: 10%;
	width: 80%;
}

#left-touch-area, #right-touch-area {
	display: none;
	position: absolute;
	top: 0;
	width: 10%;
	height: 100%;
	z-index: 2;
}
#left-touch-area {
	left: 0;
	border-right: 1px dashed #000;
}
#right-touch-area {
	right: 0;
	border-left: 1px dashed #000;
}

/*  The block element #score-top-margin-aspect is used for providing a top
	margin for the left and right score numbers that is same as their
	respective left and right margin.

	The height of the #score-top-margin-aspect element will become the same as
	its width. Therefore its width should be set to the same value as the
	margin-left and margin-right properties of the left and right score number
	containers respectively. */
#score-top-margin-aspect {
	position: relative;
	display: block;
	clear: both;
	width: 4%;
}
#score-top-margin-aspect:after {
	display: block;
	padding-top: 100%;
	content: '';
}

#top-info-bar {
	display: table;
	width: 92%;
	margin-right: 4%;
	margin-left: 4%;
	border-collapse: collapse;
}
#top-info-bar > div {
	display: table-cell;
	vertical-align: top;
}

#score-right {
	font-size: 25%;
	font-size: 6vmax;
	text-align: right;
	color: rgb(255,255,255);
}

#score-left {
	font-size: 25%;
	font-size: 6vmax;
	color: rgb(255,255,255);
}

#level-text {
	text-align: center;
	font-size: 18.75%;
	font-size: 4vmax;
	line-height: 18.75%;
	line-height: 4vmax;
	vertical-align: middle !important;
	color: #fff;
}

#paddle-left {
	position: absolute;
	width: 20px;
	height: 150px;
	top: 0;
	left: 0;
	background:rgb(255,255,255);
}

#paddle-right {
	position: absolute;
	width: 20px;
	height: 150px;
	top: 0;
	right: 0;
	background:rgb(255,255,255);
}

#ball {
	position: absolute;
	width: 20px;
	height: 20px;
	top: 50%;
	left: 50%;
	background:rgb(255,255,255);
}
</style>

<!-- Touch areas for simulating missing Fuffr case. -->

<div id="right-touch-area"></div>
<div id="left-touch-area"></div>

<div id="playfield">

	<div id="score-top-margin-aspect"></div>
	<div id="top-info-bar">
		<div id="score-left">0</div>
		<div id="level-text">Level <span id="level">1</span></div>
		<div id="score-right">0</div>
	</div>

	<div id="paddle-left"></div>
	<div id="paddle-right"></div>
	<div id="ball"></div>

</div>

<script src="lib/jquery.js"></script>
<!--<script src="lib/jquery.mobile.vtouch.js"></script>-->
<script src="lib/hammer.js"></script>
<script src="lib/fuffr.js"></script>
<script>
function touchHandler(touches)
{
	var foundLeftTouch = false;
	var foundRightTouch = false;

	for (var i = 0; i < touches.length; ++i)
	{
		var touch = touches[i]
		if (touch.side == fuffr.FFRSideLeft && !foundLeftTouch)
		{
			 foundLeftTouch = true;
			 OnLeftTouch(
			 	touch.id,
			 	touch.x,
			 	touch.y,
			 	touch.prevx,
			 	touch.prevy,
			 	touch.normx,
			 	touch.normy)
		}
		if (touch.side == fuffr.FFRSideRight && !foundRightTouch)
		{
			 foundRightTouch = true;
			 OnRightTouch(
			 	touch.id,
			 	touch.x,
			 	touch.y,
			 	touch.prevx,
			 	touch.prevy,
			 	touch.normx,
			 	touch.normy)
		}
	}
}

fuffr.on.touchesBegan = touchHandler
fuffr.on.touchesMoved = touchHandler
fuffr.on.touchesEnded = touchHandler

var fuffrWasConnected = false;

fuffr.on.connected = function()
{
	hyper.log('Fuffr Connected!')
	fuffr.enableSides(
		fuffr.FFRSideRight | fuffr.FFRSideLeft,
		1)
	fuffrWasConnected = true;
}

var checkFuffrConnection = function()
{
	if (false === fuffrWasConnected) {
		if (confirm('Fuffr wasn\'t connected. Do you want to use the simulator?')) {
			simulator.enable()
		}
	}
};

$(function() {
	setTimeout(checkFuffrConnection, 3000);
});

var lang = {};
lang.missing_init = 'Couldn\'t start the game.';

var game = {};

game.playfieldWidth = $('#playfield').width();
game.playfieldHeight = $('#playfield').height();

game.level = 1;
game.levelNumberElm = document.getElementById('level');
game.levels = 10;
game.scorePointsPerLevel = 5;
game.secondsPerLevel = 30;
game.speed = 1;
game.speedIncreasePerLevel = 2;

game.player1 = {
	score: 0,
	scoreElement : document.getElementById('score-left'),
};
game.player2 = {
	score: 0,
	scoreElement : document.getElementById('score-right'),
};

var simulator = {};

simulator.enable = function()
{
	$('#playfield').addClass('with-simulator');
	$('#left-touch-area, #right-touch-area').show();
	resetPlayfield();

	var element = document.getElementById('left-touch-area');
	Hammer(element).on("touch", function(event) {
		simulator.handleHammerTouchEvent(event, fuffr.on.touchesBegan);
	});
	Hammer(element).on("gesture", function(event) {
		simulator.handleHammerTouchEvent(event, fuffr.on.touchesMoved);
	});
	Hammer(element).on("release", function(event) {
		simulator.handleHammerTouchEvent(event, fuffr.on.touchesEnded);
	});

	var element = document.getElementById('right-touch-area');
	Hammer(element).on("touch", function(event) {
		simulator.handleHammerTouchEvent(event, fuffr.on.touchesBegan);
	});
	Hammer(element).on("gesture", function(event) {
		simulator.handleHammerTouchEvent(event, fuffr.on.touchesMoved);
	});
	Hammer(element).on("release", function(event) {
		simulator.handleHammerTouchEvent(event, fuffr.on.touchesEnded);
	});
};

simulator.disable = function()
{
	$('#left-touch-area, #right-touch-area').hide();
	$('#playfield').removeClass('with-simulator');
	resetPlayfield();
};

simulator.handleHammerTouchEvent = function(event, handler)
{
	var touches = [];

	for (var t in event.gesture.touches) {
		var touch = event.gesture.touches[t];
		if ('object' != typeof touch) continue;

		var side = null;
		if (touch.target.id == 'left-touch-area')
			side = fuffr.FFRSideLeft;
		if (touch.target.id == 'right-touch-area')
			side = fuffr.FFRSideRight;

		var touchX = touch.x || touch.clientX;
		var touchY = touch.y || touch.clientY;

		touches.push({
			id	  : touch.identifier,
			x	  : touchX,
			y	  : touchY,
			prevx : touchX,
			prevy : touchY,
			normx : touchX / touch.target.clientWidth,
			normy : touchY / touch.target.clientHeight,
			side  : side
		});
	}

	handler(touches);
};

game.start = function()
{
	if (ball == void(0) || paddleLeft == void(0) || paddleRight == void(0))
	{
		alert(lang.missing_init);
	}

	this.startLevel();
};

game.startLevel = function()
{
	if (this.mainLoop)
		window.clearInterval(this.mainLoop);

	var that = this;
	this.mainLoop = window.setInterval(function()
	{
		that.checkTimePerLevel();
		ball.move()
		paddleLeft.measureSpeed()
		paddleRight.measureSpeed()
		ball.checkLeftPaddleCollision()
		ball.checkRightPaddleCollision()
		ball.checkWallCollision()
	},
	21-game.speed);

	this.levelStartTime = (new Date().getTime());

	if (!this.startTime)
		this.startTime = this.levelStartTime;
};

game.end = function()
{
	window.clearInterval(this.mainLoop);
};

game.increaseScore = function(player) {
	player.score += 1;

	player.scoreElement.textContent = player.score;

	if ((game.player1.score + game.player2.score) % game.scorePointsPerLevel == 0)
	{
		game.nextLevel();
	}
	
	ball.setCenterX(this.playfieldWidth / 2);
	ball.setCenterY(this.playfieldHeight / 2);
}

game.nextLevel = function()
{
	this.level += 1;

	if (this.level > this.levels)
	{
		this.end();
	}
	else
	{
		game.levelNumberElm.textContent = this.level;
		game.speed += game.speedIncreasePerLevel;
		this.startLevel();
	}
};

game.getPlaytimeSeconds = function()
{
	var time = (new Date().getTime());
	return Math.round((time - game.startTime) / 1000);
};

game.getLevelPlaytimeSeconds = function()
{
	var time = (new Date().getTime());
	return Math.round((time - game.levelStartTime) / 1000);
};

game.checkTimePerLevel = function()
{
	if (this.getLevelPlaytimeSeconds() >= game.secondsPerLevel)
		this.nextLevel()
};

var makeSprite = function()
{
	var sprite = {}

	sprite.x = 0
	sprite.y = 0
	sprite.dx = 0
	sprite.dy = 0
	sprite.dt = 0

	sprite.setDOMElement = function(element)
	{
		sprite.domElement = element
		sprite.width = sprite.domElement.offsetWidth;
		sprite.height = sprite.domElement.offsetHeight;
	}

	sprite.setLeft = function(x)
	{
		sprite.x = x
		sprite.domElement.style.left = x + 'px'
	}

	sprite.setRight = function(x)
	{
		sprite.x = x - sprite.domElement.offsetWidth
		sprite.domElement.style.left = sprite.x + 'px'
	}

	sprite.setTop = function(y)
	{
		sprite.y = y
		sprite.domElement.style.top = y + 'px'
	}

	sprite.setBottom = function(y)
	{
		sprite.y = y - sprite.domElement.offsetHeight
		sprite.domElement.style.bottom = sprite.y.offsetHeight + 'px'
	}

	sprite.setCenterX = function(x)
	{
		sprite.setLeft(x - (sprite.domElement.offsetWidth / 2))
	}

	sprite.setCenterY = function(y)
	{
		sprite.setTop(y - (sprite.domElement.offsetHeight / 2))
	}

	sprite.setDeltaX = function(dx)
	{
		sprite.dx = dx
	}

	sprite.setDeltaY = function(dy)
	{
		sprite.dy = dy
	}

	sprite.getCenterX = function()
	{
		return sprite.x + (sprite.domElement.offsetWidth / 2)
	}

	sprite.getCenterY = function()
	{
		return sprite.y + (sprite.domElement.offsetHeight / 2)
	}

	sprite.getLeft = function()
	{
		return sprite.x
	}

	sprite.getRight = function()
	{
		return sprite.x + sprite.domElement.offsetWidth
	}

	sprite.getTop = function()
	{
		return sprite.y
	}

	sprite.getBottom = function()
	{
		return sprite.y + sprite.domElement.offsetHeight
	}

	sprite.move = function()
	{
		sprite.setLeft(sprite.x + sprite.dx)
		sprite.setTop(sprite.y + sprite.dy)
	}

	return sprite
}

var paddleLeft = makeSprite()
paddleLeft.setDOMElement(document.getElementById('paddle-left'))
paddleLeft.setLeft(0)
paddleLeft.setCenterY(game.playfieldHeight / 2)
paddleLeft.lastX = null
paddleLeft.lastY = null
paddleLeft.speedX = 0
paddleLeft.speedY = 0
paddleLeft.speedXMax = 0
paddleLeft.speedYMax = 50

var paddleRight = makeSprite()
paddleRight.setDOMElement(document.getElementById('paddle-right'))
paddleRight.setRight(game.playfieldWidth)
paddleRight.setCenterY(game.playfieldHeight / 2)
paddleRight.lastX = null
paddleRight.lastY = null
paddleRight.speedX = 0
paddleRight.speedY = 0
paddleRight.speedXMax = 0
paddleRight.speedYMax = 50

var ball = makeSprite()
ball.setDOMElement(document.getElementById('ball'))
ball.setCenterX(game.playfieldWidth / 2)
ball.setCenterY(game.playfieldHeight / 2)
ball.setDeltaX(4)
ball.setDeltaY(4)
ball.maxDeltaY = 5;

ball.checkWallCollision = function()
{
	var nextX = ball.getCenterX() + ball.dx
	var nextY = ball.getCenterY() + ball.dy

	// Left wall.
	if (nextX < 0 && ball.dx < 0)
	{
		ball.dx = - ball.dx
		game.increaseScore(game.player1);
	}
	// Right wall.
	else if (nextX > game.playfieldWidth && ball.dx > 0)
	{
		ball.dx = - ball.dx
		game.increaseScore(game.player2);
	}
	// Top wall.
	else if (nextY < 0 && ball.dy < 0)
	{
		ball.dy = - ball.dy
	}
	// Bottom wall.
	else if (nextY > game.playfieldHeight && ball.dy > 0)
	{
		ball.dy = - ball.dy
	}
}

ball.checkLeftPaddleCollision = function()
{
	var nextX = ball.getCenterX() + ball.dx
	var nextY = ball.getCenterY() + ball.dy

	var paddle = paddleLeft

	// Bounce if ball is within paddle bounds.
	if (nextX < paddle.getRight() &&
		nextY > paddle.getTop() &&
		nextY < paddle.getBottom() &&
		ball.dx < 0)
	{
		console.log('collide left paddle')
		ball.dx = - ball.dx

		var paddleSpeed = (paddle.speedY / paddle.speedYMax),
			collPos = ((nextY - paddle.getCenterY()) / paddle.domElement.offsetHeight),
			speedTerm = paddleSpeed * 5,
			posTerm = paddleSpeed * 0.5 * collPos,
			ballDeltaYChange = speedTerm + posTerm;

		if (ball.dy + ballDeltaYChange > ball.maxDeltaY)
			ballDeltaYChange = 2 * ballDeltaYChange - ball.maxDeltaY;

		ball.dy += ballDeltaYChange;

		//console.log('speed term=' + speedTerm + ', pos term=' + posTerm);
	}
}

ball.checkRightPaddleCollision = function()
{
	var nextX = ball.getCenterX() + ball.dx
	var nextY = ball.getCenterY() + ball.dy
	// console.log(nextY + '(' + ball.dy + ')');

	var paddle = paddleRight

	// Bounce if ball is within paddle bounds.
	if (nextX > paddle.getLeft() &&
		nextY > paddle.getTop() &&
		nextY < paddle.getBottom() &&
		ball.dx > 0)
	{
		console.log('collide right paddle')
		ball.dx = - ball.dx

		var paddleSpeed = (paddle.speedY / paddle.speedYMax),
			collPos = ((nextY - paddle.getCenterY()) / paddle.domElement.offsetHeight),
			speedTerm = paddleSpeed * 5,
			posTerm = paddleSpeed * 0.5 * collPos,
			ballDeltaYChange = speedTerm + posTerm;

		if (ball.dy + ballDeltaYChange > ball.maxDeltaY)
			ballDeltaYChange = 2 * ballDeltaYChange - ball.maxDeltaY;

		ball.dy += ballDeltaYChange;

		//console.log('speed term=' + speedTerm + ', pos term=' + posTerm);
	}
}

paddleLeft.measureSpeed =
paddleRight.measureSpeed = function()
{
	this.dt += 0.02;
	if (this.dt >= 0.1)
	{
		if (this.lastY)
			this.speedY = (this.y - this.lastY) / this.dt;
		this.lastY = this.y;
		this.dt = 0;
	}
	if (this.speedY > this.speedYMax)
		this.speedYMax = this.speedY;
};

var resetPlayfield = function()
{
	game.playfieldWidth = $('#playfield').width()
	game.playfieldHeight = $('#playfield').height()
	paddleLeft.setLeft(0)
	paddleRight.setRight(game.playfieldWidth)
};

resetPlayfield();

game.start();

function OnRightTouch(touchId, touchX, touchY, previousX, previousY, normalizedX, normalizedY)
{
	var y = (normalizedY * game.playfieldHeight)
	paddleRight.setCenterY(y)
}

function OnLeftTouch(touchId, touchX, touchY, previousX, previousY, normalizedX, normalizedY)
{
	var y = (normalizedY * game.playfieldHeight)
	paddleLeft.setCenterY(y)
}
</script>

</body>
</html>
